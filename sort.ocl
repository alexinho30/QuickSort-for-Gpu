typedef struct {
	int sstart ;
	int send ;
	int pivot_value ; 	
} sequence;


kernel void partition_first_phase_v1(const int nels, global const int * restrict in,  
const int pivot, global int * restrict lt, global int * restrict gt,  
int sstart, int send, local int * restrict acc_inf, local int * restrict acc_sup
) {
    const int i = get_global_id(0);
    const int li = get_local_id(0);
    const int gi = get_group_id(0);

    int v;

    v = in[i + sstart];
 
    if(li == 0){
        (*acc_inf) = 0 ; 
        (*acc_sup) = 0 ; 
    }

    for(int h = 0 ; h < get_local_size(0) ; h++){
        barrier(CLK_LOCAL_MEM_FENCE) ; 
        if(get_local_id(0) == h){
            if(v < pivot && i < send - sstart + 1){
                (*acc_inf)++ ; 
            }
            else if(v > pivot && i < send - sstart + 1){
                (*acc_sup)++ ; 
            }
        }
    }

    barrier(CLK_LOCAL_MEM_FENCE);

    if (li == 0) {
        lt[gi + 1] = *acc_inf;
        gt[gi + 1] = *acc_sup;
    }
}

kernel void partition_second_phase_v1(
    global const int * restrict in, 
    global int * restrict out, const int pivot, 
    global int * restrict lt, global int * restrict gt,
    int sstart, int send, int nels,
    global int * restrict pivot_pos, 
    const int n_wg_to_order, 
    local int * restrict count_inf, local int * restrict count_sup
) {
    const int i = get_global_id(0);
    const int li = get_local_id(0);
    const int gi = get_group_id(0);

    if(i + sstart> send && i < nels){
        int index = (i + sstart)%nels ; 
        out[index] = in[index] ; 
    }

    if (li == 0) { 
        *count_inf = lt[gi] + sstart;
        *count_sup = send - gt[gi] ;
    }

    int v = in[i + sstart];

    for(int h = 0 ; h < get_local_size(0) ; h++){
        barrier(CLK_LOCAL_MEM_FENCE);
        if(h == get_local_id(0)){
            if (v < pivot && i + sstart <= send) {
                out[*count_inf] = v ; 
                (*count_inf)++ ; 
            }
           if (v > pivot && i + sstart <= send) {
                out[*count_sup] = v;
                (*count_sup)-- ; 
            }
        }
    }

    if(i == 0){
        const int pivot_start = lt[n_wg_to_order] + sstart ; 
        const int pivot_end = send - gt[n_wg_to_order] + 1 ; 
        *pivot_pos = pivot_end - 1;
        for(int h = pivot_start; h < pivot_end ; h++){
            out[h] = pivot ; 
        }
    }
}

kernel void partion_final_v1(global int* restrict in, global const int* restrict sstart, 
        global const int* restrict send, const int nels, const int number_of_sequences, const int min_seq_len, local int* restrict stack_sstart,
        local int* restrict stack_send, local int* current_size,  local int* restrict lt, local int* restrict gt, 
        local int* current_sstart, local int* current_send, local int* pivot, local int* pivot_elements){

            const int i = get_global_id(0) ; 
            const int li = get_local_id(0) ; 
            const int gi = get_group_id(0) ; 

            if(li == 0){  
                *current_size = 0 ;
                *pivot = 0 ;  
                stack_sstart[*current_size] = sstart[gi] ; 
                stack_send[*current_size] = send[gi] ;   
            }

            barrier(CLK_LOCAL_MEM_FENCE) ; 

            while(*current_size != -1){
    
                barrier(CLK_LOCAL_MEM_FENCE) ; 

                if(li == 0){ 
                    *current_sstart = stack_sstart[*current_size] ; 
                    *current_send = stack_send[*current_size] ; 
                    *pivot =  in[*current_sstart + (*current_send - *current_sstart + 1)/2] ; 
                    (*current_size)-- ; 
                }

                barrier(CLK_LOCAL_MEM_FENCE) ; 

                const int _current_sstart = *current_sstart ; 
                const int _current_send = *current_send ; 
                
                int v ;
                const int current_index = li + _current_sstart ; 
                if( current_index <= _current_send){
                    v = in[current_index] ; 
                } 

                if( v < *pivot && current_index <= _current_send){
                    lt[li + 1] = 1 ; 
                }
                else{
                    lt[li + 1] =  0 ; 
                }
                 
                if(v > *pivot && current_index <= _current_send){
                    gt[li + 1] = 1 ; 
                }
                else{
                    gt[li + 1] = 0 ; 
                }

                if(v == *pivot && current_index <= _current_send){
                    pivot_elements[li] = 1 ; 
                }
                else{
                    pivot_elements[li] = 0 ; 
                }

                barrier(CLK_LOCAL_MEM_FENCE) ; 

                if(li == 0){
                    for(int h = 1 ; h <= _current_send - _current_sstart + 1  ; h++){
                        lt[h] += lt[h - 1] ; 
                        gt[h] += gt[h - 1] ;
                    }
                }
                
                barrier(CLK_LOCAL_MEM_FENCE) ; 
               
                if(v < *pivot && lt[li] < lt[li + 1] && current_index <= _current_send){ 
                    in[_current_sstart + lt[li]] = v ; 
                }

                if(v > *pivot && gt[li] < gt[li + 1] && current_index <= _current_send){ 
                    in[_current_send - gt[li]] = v ;
                }

                barrier(CLK_LOCAL_MEM_FENCE) ; 

                if(li == 0){
                    for(int h = _current_sstart + lt[_current_send - _current_sstart + 1] ; h < _current_send - gt[_current_send - _current_sstart + 1] + 1 ; h++){
                        in[h] = *pivot ; 
                    }

                    for(int h = 1 ; h < get_local_size(0) ; h++){
                        pivot_elements[h]+=pivot_elements[h -1] ; 
                        pivot_elements[h - 1] = 0 ;
                    }
                
                    sequence s1, s2 ; 

                    s1.sstart = _current_sstart ; 
                    s1.send = _current_sstart + lt[_current_send - _current_sstart + 1]+ pivot_elements[get_local_size(0) -  1] - 1 ;
                    const int s1_dim = s1.send - s1.sstart + 1 ; 
    
                    s2.sstart = _current_send - gt[_current_send - _current_sstart + 1]  + 1 ;                 
                    s2.send = _current_send ;
                    const int s2_dim = s2.send - s2.sstart + 1 ;
                
                    if(s1_dim > min_seq_len && lt[_current_send - _current_sstart + 1] > 0 && gt[_current_send - _current_sstart + 1] > 0 ){
                        stack_sstart[++(*current_size)] = s1.sstart ; 
                        stack_send[(*current_size)] = s1.send ; 
                    }
                    else if(s1.send - s1.sstart > 0){
                        for(int h = 0 ; h < s1_dim ; h++ ){
                            for(int t = 0 ; t < s1_dim - 1; t++){
                                if(in[t + s1.sstart] > in[t + 1 + s1.sstart]){
                                    int tmp = in[t + s1.sstart] ; 
                                    in[t + s1.sstart] = in[t + 1 + s1.sstart] ; 
                                    in[t + 1 + s1.sstart] = tmp ; 
                                }
                            } 
                        }
                    
                    }

                    if(s2_dim > min_seq_len &&  lt[_current_send - _current_sstart + 1] > 0 && gt[_current_send - _current_sstart + 1] > 0){
                        stack_sstart[++(*current_size)] = s2.sstart ; 
                        stack_send[(*current_size)] = s2.send ; 
                    }
                    else if(s2.send - s2.sstart >0){
                        for(int h = 0 ; h < s2_dim ; h++ ){
                            for(int t = 0 ; t < s2_dim - 1; t++){
                                if(in[t + s2.sstart] > in[t + 1 + s2.sstart]){
                                    int tmp = in[t + s2.sstart] ; 
                                    in[t + s2.sstart] = in[t + 1 + s2.sstart] ; 
                                    in[t + 1 + s2.sstart] = tmp ; 
                                }
                            } 
                        }
                    }
                } 
                barrier(CLK_LOCAL_MEM_FENCE) ; 
            } 
        }


/*kernel void partition_first_phase_v2(const int nels, global const int * restrict in,  
const int pivot, global int * restrict lt, global int * restrict gt,  
int sstart, int send, local int * restrict arr_inf, local int * restrict arr_sup
){
    int i = get_global_id(0) ; 
    const int li = get_local_id(0) ; 
    const int gi = get_group_id(0) ;
    const int wg_dim = get_local_size(0) ;
    const int gs = get_global_size(0) ;  

    int v_sup = 0 ;
    int v_inf = 0 ; 

    while(i < nquarts){
        int v = in[sstart + i] ;  

        if(v < pivot && i < send -sstart + 1){
           v_inf++ ;  
        }
        else if(v > pivot && i < send -sstart + 1){
            v_sup++ ;  
        } 
        i += gs ;
    }

    arr_sup[li] = v_sup ; 
    arr_inf[li] = v_inf ; 

  //  if(gi == 0){
        printf("gi : %d arr_sup[%d] = %d \n", gi, li, arr_sup[li]) ; 
        printf("gi : %d arr_inf[%d] = %d \n", gi, li, arr_inf[li]) ; 
 //   }

    int active = get_local_size(0)/2 ; 
    
    while(active > 0){
        barrier(CLK_LOCAL_MEM_FENCE);
        if(li < active){
            v_sup += arr_sup[li + active] ; 
            v_inf += arr_inf[li + active] ; 
            arr_sup[li] = v_sup ; 
            arr_inf[li] = v_inf ; 
        }
        active/=2 ; 
    }

    if(li == 0){
        lt[gi + 1] = v_inf ; 
        gt[gi + 1] = v_sup ;
    }
}
*/