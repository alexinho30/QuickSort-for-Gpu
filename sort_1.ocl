typedef struct {
	int sstart ;
	int send ;
	int pivot_value ; 	
} sequence;


kernel void partition_v1(const int nels, global const int * restrict in,  
const int pivot, global int * restrict lt, global int * restrict gt, // lt and gt must be group size 
int sstart, int send, local int * restrict acc_inf, local int * restrict acc_sup
) {
    const int i = get_global_id(0);
    const int li = get_local_id(0);
    const int gi = get_group_id(0);

    int4 v = (int4)(in[i + sstart], in[i + 1 + sstart], in[i + 2 + sstart], in[i + 3 + sstart]);

    if(li == 0){
        (*acc_inf) = 0 ; 
        (*acc_sup) = 0 ; 
    }

    for(int h = 0 ; h < get_local_size(0) ; h++){
        barrier(CLK_LOCAL_MEM_FENCE) ; 
        if(li == h){
            if(v.s0 < pivot && i < send - sstart + 1){
                (*acc_inf)++ ; 
            }
            else if(v.s0 > pivot && i < send - sstart + 1){
                (*acc_sup)++ ; 
            }

            if(v.s1 < pivot && i + 1< send - sstart + 1){
                (*acc_inf)++ ; 
            }
            else if(v.s1 > pivot && i + 1< send - sstart + 1){
                (*acc_sup)++ ; 
            }

            if(v.s2 < pivot && i + 2< send - sstart + 1){
                (*acc_inf)++ ; 
            }
            else if(v.s2 > pivot && i + 2< send - sstart + 1){
                (*acc_sup)++ ; 
            }

            if(v.s3 < pivot && i + 3< send - sstart + 1){
                (*acc_inf)++ ; 
            }
            else if(v.s3 > pivot && i + 3< send - sstart + 1){
                (*acc_sup)++ ; 
            }
            printf("li : %d , acc_sup : %d acc_inf : %d\n", li, *acc_sup, *acc_inf) ; 
        }
    }

    barrier(CLK_LOCAL_MEM_FENCE);

    if (li == 0) {
        lt[gi + 1] = *acc_inf;
        gt[gi + 1] = *acc_sup;
    }
}

// 3 4 5 2 | 4 5 7 1 3

kernel void partition_v2(
    global const int * restrict in, 
    global int * restrict out, const int pivot, 
    global int * restrict lt, global int * restrict gt,
    int sstart, int send, int nels,
    global int * restrict pivot_pos, 
    const int n_wg_to_order, 
    local int * restrict count_inf, local int * restrict count_sup
) {
    const int i = get_global_id(0);
    const int li = get_local_id(0);
    const int gi = get_group_id(0);

    if(i + sstart> send && i < nels){
        int index = (i + sstart)%nels ; 
        out[index] = in[index] ; 
    }

    if (li == 0) { 
        *count_inf = lt[gi] + sstart;
        *count_sup = send - gt[gi] ;
    }

    int v = in[i + sstart];

    for(int h = 0 ; h < get_local_size(0) ; h++){
        barrier(CLK_LOCAL_MEM_FENCE);
        if(h == get_local_id(0)){
            if (v < pivot && i + sstart <= send) {
                out[*count_inf] = v ; 
                (*count_inf)++ ; 
            }
           if (v > pivot && i + sstart <= send) {
                out[*count_sup] = v;
                (*count_sup)-- ; 
            }
        }
    }

    if(i == 0){
        const int pivot_start = lt[n_wg_to_order] + sstart ; 
        const int pivot_end = send - gt[n_wg_to_order] + 1 ; 
        *pivot_pos = pivot_end - 1;
        for(int h = pivot_start; h < pivot_end ; h++){
            out[h] = pivot ; 
        }
    }
}

// 2 3 1 8 7 5 3 2 | 13 7 9 3 2 1 9 1|  

// 2 3 1 3 2 9 7 8 6


kernel void partion_final(global int* restrict in, global int* restrict out, global const int* restrict sstart, 
        global const int* restrict send, const int nels, const int number_of_sequences, const int min_seq_len, local int* restrict stack_sstart,
        local int* restrict stack_send, local int* current_size,  local int* restrict lt, local int* restrict gt, 
        local int* current_sstart, local int* current_send, local int* pivot, local int* pivot_elements){

            const int i = get_global_id(0) ; 
            const int li = get_local_id(0) ; 
            const int gi = get_group_id(0) ; 

            int cont = 0 ; 

            if(li == 0){  
                *current_size = 0 ;
                *pivot = 0 ;  
                stack_sstart[*current_size] = sstart[gi] ; 
                stack_send[*current_size] = send[gi] ;   
            }

            barrier(CLK_LOCAL_MEM_FENCE) ; 

            while(*current_size != -1){
    
                barrier(CLK_LOCAL_MEM_FENCE) ; 

                if(li == 0){
                    pivot_elements[get_local_size(0) - 1] = 0 ; 
                    *current_sstart = stack_sstart[*current_size] ; 
                    *current_send = stack_send[*current_size] ; 
                    *pivot =  in[*current_sstart + (*current_send - *current_sstart + 1)/2] ; 
                    (*current_size)-- ; 
                }

                barrier(CLK_LOCAL_MEM_FENCE) ; 

                const int _current_sstart = *current_sstart ; 
                const int _current_send = *current_send ; 
                
                int v ;
                const int local_current_sstart = li + _current_sstart ; 
                if( local_current_sstart <= _current_send){
                    v = in[local_current_sstart] ; 
                } 

                if( v < *pivot && local_current_sstart <= _current_send){
                    lt[li + 1] = 1 ; 
                }
                else{
                    lt[li + 1] =  0 ; 
                }
                 
                if(v > *pivot && local_current_sstart <= _current_send){
                    gt[li + 1] = 1 ; 
                }
                else{
                    gt[li + 1] = 0 ; 
                }

                if(v == *pivot && local_current_sstart <= _current_send){
                    pivot_elements[li] = 1 ; 
                }
                else{
                    pivot_elements[li] = 0 ; 
                }

                barrier(CLK_LOCAL_MEM_FENCE) ; 

                if(li == 0){
                    for(int h = 1 ; h <= _current_send - _current_sstart + 1  ; h++){
                        lt[h] += lt[h - 1] ; 
                        gt[h] += gt[h - 1] ;
                    }
                }
                
                barrier(CLK_LOCAL_MEM_FENCE) ; 
               
                if(v < *pivot && lt[li] < lt[li + 1] && local_current_sstart <= _current_send){ 
                    in[_current_sstart + lt[li]] = v ; 
                }

                if(v > *pivot && gt[li] < gt[li + 1] && local_current_sstart <= _current_send){
                    in[_current_send - gt[li]] = v ;
                }

                barrier(CLK_LOCAL_MEM_FENCE) ; 

                if(li == 0){
                    for(int h = _current_sstart + lt[_current_send - _current_sstart + 1] ; h < _current_send - gt[_current_send - _current_sstart + 1] + 1 ; h++){
                        in[h] = *pivot ; 
                    }

                    for(int h = 1 ; h < get_local_size(0) ; h++){
                        pivot_elements[h]+=pivot_elements[h -1] ; 
                        pivot_elements[h - 1] = 0 ;
                    }
                
                    sequence s1, s2 ; 

                    s1.sstart = _current_sstart ; 
                    s1.send = _current_sstart + lt[_current_send - _current_sstart + 1] - 1 ;
                    const int s1_dim = s1.send - s1.sstart + 1 ; 
    
                    s2.sstart = _current_send - gt[_current_send - _current_sstart + 1] - pivot_elements[get_local_size(0) - 1] + 1 ;
                    s2.send = _current_send ;
                    const int s2_dim = s2.send - s2.sstart + 1 ;
                
                    if(s1_dim > min_seq_len){
                        stack_sstart[++(*current_size)] = s1.sstart ; 
                        stack_send[(*current_size)] = s1.send ; 
                    }
                    else if(s1.send - s1.sstart > 0){
                        for(int h = 0 ; h < s1_dim ; h++ ){
                            for(int t = 0 ; t < s1_dim - 1; t++){
                                if(in[t + s1.sstart] > in[t + 1 + s1.sstart]){
                                    int tmp = in[t + s1.sstart] ; 
                                    in[t + s1.sstart] = in[t + 1 + s1.sstart] ; 
                                    in[t + 1 + s1.sstart] = tmp ; 
                                }
                            } 
                        }
                    
                    }

                    if(s2_dim > min_seq_len){
                        stack_sstart[++(*current_size)] = s2.sstart ; 
                        stack_send[(*current_size)] = s2.send ; 
                    }
                    else if(s2.send - s2.sstart >0){
                        for(int h = 0 ; h < s2_dim ; h++ ){
                            for(int t = 0 ; t < s2_dim - 1; t++){
                                if(in[t + s2.sstart] > in[t + 1 + s2.sstart]){
                                    int tmp = in[t + s2.sstart] ; 
                                    in[t + s2.sstart] = in[t + 1 + s2.sstart] ; 
                                    in[t + 1 + s2.sstart] = tmp ; 
                                }
                            } 
                        }
                    }
                } 
            }
        }





/* 3 4 1 7 12 | 5 77 31 0 2 lws = 5 pivot = 7
    
lt[0] = 2 lt[1] = 1 lt[2] = 1 lt[3] = 1 lt[4] = 1
gt[0] = 0 gt[1] = 1 gt[2] = 1 gt[3] = 1 gt[4] = 1
*/ 

/*
lt[0] = 1 lt[1] = 1 lt[2] = 1 lt[3] = 0  lt[4] = 0
gt[0] = 0 gt[1] = 0 gt[2] = 0 gt[3] = 1  gt[4] = 1 
*/

/*
-provare ad includere il pivot in gt o lt 
-calcolare solo lt o solo gt
-raddioppare la dimensione della sequenza minima 
*/

/*
if(gi == 1){
    printf("s1.sstart : %d s1.send : %d\n", s1.sstart, s1.send) ;
    printf("s2.sstart : %d s2.send : %d\n", s2.sstart, s2.send) ;  
for(int h = s1.sstart ; h <= s1.send ; h++){
        printf("s1[%d] = %d \n", h, out[h]) ; 
    }
    for(int h = s2.sstart ; h <= s2.send ; h++){
        printf("s2[%d] = %d \n", h, out[h]) ; 
    }
}
*/
